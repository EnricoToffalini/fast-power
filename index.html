<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Enrico Toffalini &amp; Filippo Gambarota">
<meta name="dcterms.date" content="2025-06-12">

<title>Optimizing Power Simulation  - The Standard Error Algorithm in Action</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link rel="shortcut icon" href="assets/faviconpsicostat2.png">
</head><body><img src="assets/psicostatLogo.png" alt="Logo" style="width:50px; margin: 5px auto; display: block; margin-top: 10px;">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>





<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#the-idea" id="toc-the-idea" class="nav-link active" data-scroll-target="#the-idea"><span class="header-section-number">1</span> The idea</a></li>
  <li><a href="#the-algorithm-more-or-less" id="toc-the-algorithm-more-or-less" class="nav-link" data-scroll-target="#the-algorithm-more-or-less"><span class="header-section-number">2</span> The Algorithm, more or less</a></li>
  <li><a href="#three-example-scenarios" id="toc-three-example-scenarios" class="nav-link" data-scroll-target="#three-example-scenarios"><span class="header-section-number">3</span> Three example scenarios</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results"><span class="header-section-number">4</span> Results</a></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions"><span class="header-section-number">5</span> Conclusions</a></li>
  <li><a href="#future-directions" id="toc-future-directions" class="nav-link" data-scroll-target="#future-directions"><span class="header-section-number">6</span> Future directions</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Optimizing Power Simulation <br>- The Standard Error Algorithm in Action</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Enrico Toffalini &amp; Filippo Gambarota </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 12, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(effects)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(toffee) <span class="co"># devtools::install_github("enricotoffalini/toffee")</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"R/StdErr algorithm function.R"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>(<span class="st">"R/simulations.RData"</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="the-idea" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> The idea</h1>
<p>Running a full power simulation can be computationally expensive, especially when the statistical model is complex and there is little prior knowledge about the sample size (or other parameters) required to achieve a desired level of power (e.g., 80%). In two pre-registrations I personally worked on last year, both involving mixed-effects logistic regressions with nested and crossed random effects, a single iteration using a realistic sample size (on the order of hundreds) took around one minute. This meant that running 5,000 iterations on a single core would have taken days. Parallelizing the simulations across 8 cores reduced this to less than one day per scenario, but even then, running a full grid of alternative scenarios becomes prohibitive unless one have powerful servers. This becomes critical when collaborating with others and working under time constraints. This illustrates why a full power simulation is often too costly when the required sample size is unknown or when multiple scenarios must be explored. Complex statistical models, not just simple t-tests, are becoming the norm in real-world psychological research.</p>
<p>To simplify the discussion, let‚Äôs assume we are interested in estimating only the required sample size <span class="math inline">\(N\)</span>, while keeping constant other relevant parameters that affect power (e.g., number of trials <span class="math inline">\(k\)</span>, or measure reliability <span class="math inline">\(\omega\)</span>). However, the procedure presented below can be easily extended to cases where multiple parameters vary simultaneously.</p>
<p>The idea is as follows: although full power simulation is costly, in many cases (though not all), there is a relatively fast workaround for obtaining a sufficiently precise estimate of the required sample size to achieve the desired power. This approach applies when we fit parametric models and are interested in the power to detect a parameter estimate <span class="math inline">\(B\)</span> as statistically significant, given its associated standard error (<span class="math inline">\(StdErr\)</span>). The key points are:</p>
<ul>
<li>A well-defined <span class="math inline">\(z\)</span>-score (i.e., <span class="math inline">\(B / \text{StdErr}\)</span>) corresponds to the desired power level;</li>
<li>The relationship between <span class="math inline">\(StdErr\)</span> and <span class="math inline">\(N\)</span> is approximately <span class="math inline">\(\log(\text{StdErr}) \sim -0.5 \times \log(N)\)</span>. This is due to the fact that:</li>
</ul>
<p><span class="math display">\[StdErr \approx \frac{\sigma}{\sqrt{N}}\]</span></p>
<p>The first point is illustrated in the plot below: the red curve shows the sampling distribution of <span class="math inline">\(B\)</span> under the null hypothesis (<span class="math inline">\(H_0\)</span>), while the blue curve represents the expected distribution of <span class="math inline">\(B\)</span> under the alternative hypothesis (<span class="math inline">\(H_1\)</span>), assuming an effect size of 0.30. The statistical power under <span class="math inline">\(H_1\)</span> is 80%, which is achieved when <span class="math inline">\(StdErr = 0.107\)</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>B <span class="ot">=</span> <span class="fl">0.30</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>se <span class="ot">=</span> toffee<span class="sc">::</span><span class="fu">SE4power</span>(<span class="at">B=</span><span class="fl">0.30</span>, <span class="at">power=</span><span class="fl">0.8</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>()<span class="sc">+</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_cartesian</span>(<span class="at">xlim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.35</span>,<span class="fl">0.7</span>))<span class="sc">+</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">stat_function</span>(<span class="at">fun=</span>dnorm,<span class="at">args=</span><span class="fu">list</span>(<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span>se),<span class="at">xlim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="dv">3</span>,<span class="dv">3</span>),<span class="at">color=</span><span class="cn">NA</span>,<span class="at">fill=</span><span class="st">"red"</span>,<span class="at">geom=</span><span class="st">"area"</span>,<span class="at">alpha=</span>.<span class="dv">3</span>, <span class="at">n=</span><span class="fl">1e3</span>)<span class="sc">+</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_vline</span>(<span class="at">xintercept=</span><span class="fu">qnorm</span>(<span class="fu">c</span>(<span class="fl">0.025</span>,<span class="fl">0.975</span>))<span class="sc">*</span>se,<span class="at">color=</span><span class="st">"black"</span>,<span class="at">linetype=</span><span class="dv">2</span>,<span class="at">linewidth=</span><span class="dv">1</span>)<span class="sc">+</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_vline</span>(<span class="at">xintercept=</span><span class="fu">c</span>(<span class="dv">0</span>,B),<span class="at">color=</span><span class="fu">c</span>(<span class="st">"red"</span>,<span class="st">"blue"</span>),<span class="at">linetype=</span><span class="dv">1</span>,<span class="at">linewidth=</span><span class="dv">1</span>)<span class="sc">+</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">stat_function</span>(<span class="at">fun=</span>dnorm,<span class="at">args=</span><span class="fu">list</span>(<span class="at">mean=</span>B,<span class="at">sd=</span>se),<span class="at">xlim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="dv">3</span>,<span class="dv">3</span>),<span class="at">color=</span><span class="cn">NA</span>,<span class="at">fill=</span><span class="st">"blue"</span>,<span class="at">geom=</span><span class="st">"area"</span>,<span class="at">alpha=</span>.<span class="dv">3</span>, <span class="at">n=</span><span class="fl">1e3</span>)<span class="sc">+</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">text=</span><span class="fu">element_text</span>(<span class="at">size=</span><span class="dv">20</span>))<span class="sc">+</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_continuous</span>(<span class="at">breaks=</span><span class="fu">seq</span>(<span class="sc">-</span><span class="dv">10</span>,<span class="dv">10</span>,.<span class="dv">1</span>))<span class="sc">+</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">annotate</span>(<span class="st">"text"</span>, <span class="at">x =</span> <span class="dv">0</span><span class="fl">+.035</span>, <span class="at">y =</span> <span class="fu">dnorm</span>(<span class="dv">0</span>, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> se) <span class="sc">+</span> <span class="fl">0.2</span>,</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>           <span class="at">label =</span> <span class="st">"H0"</span>, <span class="at">size =</span> <span class="dv">6</span>, <span class="at">color =</span> <span class="st">"red"</span>) <span class="sc">+</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">annotate</span>(<span class="st">"text"</span>, <span class="at">x =</span> B<span class="fl">+.035</span>, <span class="at">y =</span> <span class="fu">dnorm</span>(B, <span class="at">mean =</span> B, <span class="at">sd =</span> se) <span class="sc">+</span> <span class="fl">0.2</span>,</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>           <span class="at">label =</span> <span class="st">"H1"</span>, <span class="at">size =</span> <span class="dv">6</span>, <span class="at">color =</span> <span class="st">"blue"</span>)<span class="sc">+</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"B"</span>) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">"density"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The target standard error can be computed as follows:</p>
<p><span class="math display">\[
criticalStdErr = \frac{|\!B|}{\Phi^{-1}(1 - \alpha) + \Phi^{-1}(\text{power})}
\]</span></p>
<p>where <span class="math inline">\(\Phi^{-1}\)</span> denotes the quantile function of the standard normal distribution, <span class="math inline">\(\alpha\)</span> is the significance level (e.g., 0.05), and ‚Äúpower‚Äù is the desired statistical power (e.g., 0.80).</p>
<p>To summarize, the idea is to identify the value of <span class="math inline">\(N\)</span> that is, on average, associated with the desired <span class="math inline">\(StdErr\)</span>, taking advantage of the approximately stable relationship between them.</p>
</section>
<section id="the-algorithm-more-or-less" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> The Algorithm, more or less</h1>
<p>The proposed algorithm (see code <a href="StdErr algorithm function.R" target="_blank">here</a>) can be summarized as follows:</p>
<ol type="1">
<li><p>Provide a simulation function that takes as input the sample size <span class="math inline">\(N\)</span> and effect size <span class="math inline">\(B\)</span>, runs a single iteration, and returns the estimated standard error (<span class="math inline">\(StdErr\)</span>) of the parameter of interest.</p></li>
<li><p>Compute the <em>target <span class="math inline">\(StdErr\)</span></em>, i.e., the standard error that would yield the desired power (e.g., 80%) for the chosen effect size <span class="math inline">\(B\)</span> (see formula above).</p></li>
<li><p>Begin with a small <span class="math inline">\(N\)</span> and run a single simulation:</p>
<ul>
<li>If the returned <span class="math inline">\(StdErr\)</span> is <strong>larger</strong> than the target <span class="math inline">\(StdErr\)</span>, increase <span class="math inline">\(N\)</span>;</li>
<li>If the returned <span class="math inline">\(StdErr\)</span> is <strong>smaller</strong>, decrease <span class="math inline">\(N\)</span>.</li>
</ul></li>
<li><p>Repeat the above process for several iterations to explore the <span class="math inline">\(StdErr\)</span>‚Äì<span class="math inline">\(N\)</span> relationship.</p></li>
<li><p>Once a few observations have been collected, fit a simple linear model using the log‚Äìlog relationship:</p>
<p><span class="math display">\[
\log(\text{StdErr}) \sim \log(N)
\]</span></p></li>
<li><p>Use this model to iteratively refine the estimate of <span class="math inline">\(N\)</span> that would yield the target <span class="math inline">\(StdErr\)</span>, concentrating further iterations around the predicted value.</p></li>
<li><p>Stop the procedure when sufficient precision is reached, the maximum number of iterations is exhausted, or a predefined time limit is hit. Take the estimated <span class="math inline">\(N\)</span> corresponding to the target <span class="math inline">\(StdErr\)</span> as the final estimate of the required sample size.</p></li>
<li><p>To confirm, run a full power simulation using this estimated <span class="math inline">\(N\)</span> and verify that the achieved power matches expectations.</p></li>
</ol>
<p>This procedure can often identify the required <span class="math inline">\(N\)</span> in just a few dozen iterations, many of which are even run with <span class="math inline">\(N\)</span> well below the final estimate, saving computational time. Alternatively, it may allow you to perform a full power simulation on a single, highly plausible <span class="math inline">\(N\)</span>, rather than evaluating an entire vector of candidate <span class="math inline">\(N\)</span>s, thus reducing computational time by at least one order of magnitude.</p>
</section>
<section id="three-example-scenarios" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Three example scenarios</h1>
<p>Now let‚Äôs consider three plausible (though somewhat specific) simulation scenarios that require power estimation. These scenarios were selected because they represent clearly distinct types of statistical models, but in all cases the parameter of interest has an associated standard error. In each scenario, <span class="math inline">\(B\)</span> is set so that statistical power reaches approximately 70‚Äì80% when <span class="math inline">\(N = 600\)</span>.</p>
<p>üí• <strong><em>‚Äú<a href="R/simulationCode/DifferentSigma.R" target="_blank">Different Sigma</a>‚Äù</em></strong>: A simple linear model, where the goal of the power simulation is to detect a difference in residual standard deviations (<span class="math inline">\(\sigma\)</span>) across two categorical groups. The parameter of interest, <span class="math inline">\(B\)</span> (not shown in the equation), represents the logarithm of the ratio between the group-specific residual standard deviations. A single iteration with <span class="math inline">\(N = 600\)</span> takes approximately 0.0048 minutes; running 5,000 iterations on a single core takes about 25 minutes, while simulating a vector of 10 alternative <span class="math inline">\(N\)</span> values takes roughly 4 hours.</p>
<p><span class="math display">\[y_i = \beta_0 + \beta_1x_i + \varepsilon_i, \quad \varepsilon_i \sim \mathcal{N}(0, \sigma_{g_i}^2)\]</span> <span class="math display">\[\sigma_{g_i} =
    \begin{cases}
        \sigma_A, &amp; \text{if } g_i = A, \\
        \sigma_B, &amp; \text{if } g_i = B.
    \end{cases}\]</span></p>
<p><span class="math display">\[B = \log\left( \frac{\sigma_B}{\sigma_A} \right)\]</span></p>
<p>üí• <strong><em>‚Äú<a href="R/simulationCode/SEMmultigroup.R" target="_blank">SEM Multigroup</a>‚Äù</em></strong>: A structural equation model with two latent variables, <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, each measured by five observed indicators, where <span class="math inline">\(Y \sim X\)</span>. The parameter of interest is the difference in the regression coefficient linking <span class="math inline">\(X\)</span> to <span class="math inline">\(Y\)</span> across two groups. A single iteration with <span class="math inline">\(N = 600\)</span> takes approximately 0.0035 minutes; 5,000 iterations take about 17.5 minutes, and evaluating 10 different <span class="math inline">\(N\)</span> values takes around 3 hours.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="simulationCode/SEMplot.png" class="img-fluid figure-img" style="width:70.0%"></p>
<figcaption>Description of the SEM path diagram</figcaption>
</figure>
</div>
<p><span class="math display">\[
Y \sim \beta_g X, \quad \text{with} \quad \text{group } g \in \{1, 2\}
\]</span></p>
<p><span class="math display">\[
H_0: \beta_1 = \beta_2 \quad \text{vs.} \quad H_1: \beta_1 \neq \beta_2
\]</span> Inference is made on the difference parameter <code>diff</code>: <span class="math display">\[
\text{diff} := \beta_1 - \beta_2
\]</span></p>
<p>üí• <strong><em>‚Äú<a href="R/simulationCode/MixedLogisticCrossed.R" target="_blank">Mixed-effects Logistic Regression</a>‚Äù</em></strong>: A logistic regression with crossed random effects. The goal is to estimate power for detecting an interaction between a continuous within-participant predictor and a categorical between-participants predictor on a binary accuracy outcome. This scenario is a simplified version of one of the preregistered studies mentioned earlier. A single iteration with <span class="math inline">\(N = 600\)</span> takes approximately 0.38 minutes; running 5,000 iterations takes about 1.3 days, and evaluating 10 alternative <span class="math inline">\(N\)</span> values would require nearly 2 weeks on a single core.</p>
<p><span class="math display">\[
\begin{align}
\text{logit}(\Pr(\text{acc}_i = 1)) &amp;= \beta_0 + \beta_1 \cdot \text{Block}_i + \beta_2 \cdot \text{Group}_i \\
&amp;\quad + \beta_3 \cdot (\text{Block}_i \cdot \text{Group}_i) + u_{\text{id}[i]} + u_{\text{id}[i]}^{(s)} \cdot \text{Block}_i + v_{\text{item}[i]}
\end{align}
\]</span></p>
<ul>
<li><span class="math inline">\(u_{\text{id}[i]} \sim \mathcal{N}(0, \tau_{\text{intercept}})\)</span>: random intercept for participant</li>
<li><span class="math inline">\(u_{\text{id}[i]}^{(s)} \sim \mathcal{N}(0, \tau_{\text{slope}})\)</span>: random slope for <code>Block</code> by participant</li>
<li><span class="math inline">\(v_{\text{item}[i]} \sim \mathcal{N}(0, \omega)\)</span>: random intercept for item</li>
</ul>
<p>The parameter of interest is the fixed-effect interaction coefficient between <code>Block</code> and <code>Group</code>: <span class="math display">\[H_0: \beta_3 = 0 \quad \text{vs.} \quad H_1: \beta_3 \neq 0\]</span></p>
</section>
<section id="results" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Results</h1>
<section id="different-sigma-scenario" class="level3" data-number="4.0.1">
<h3 data-number="4.0.1" class="anchored" data-anchor-id="different-sigma-scenario"><span class="header-section-number">4.0.1</span> ‚ÄúDifferent Sigma‚Äù scenario</h3>
<p>Plausible effect size is set as <span class="math inline">\(B\)</span> = 0.16 (<span class="math inline">\(\sigma\)</span> is about 1.17 times in one group compared to the other). So, for 80% power, target <span class="math inline">\(StdErr\)</span> = 0.0535.</p>
<p>Let‚Äôs run with a maximum of 60 iterations:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"R/simulationCode/DifferentSigma.R"</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>B <span class="ot">=</span> <span class="fl">0.16</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>target_se <span class="ot">=</span> toffee<span class="sc">::</span><span class="fu">SE4power</span>(<span class="at">B=</span>B, <span class="at">power=</span><span class="fl">0.8</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>Start <span class="ot">=</span> <span class="fu">Sys.time</span>()</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="fu">StdErr_power</span>(<span class="at">simData=</span>simData, <span class="at">target_SE =</span> target_se,</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>                 <span class="at">warm_up =</span> <span class="dv">30</span>, <span class="at">max_niter =</span> <span class="dv">30</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>End <span class="ot">=</span> <span class="fu">Sys.time</span>()</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>timetaken <span class="ot">=</span> <span class="fu">difftime</span>(End,Start,<span class="at">units=</span><span class="st">"mins"</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>x<span class="sc">$</span>N</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>x<span class="sc">$</span>plot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>Estimated N = 618 (95%CI: 616, 619)</li>
<li>Time taken for reaching the estimate is 0.6 minutes.</li>
</ul>
<p><strong>Double check:</strong> full power simulation with <span class="math inline">\(N\)</span> = 618 and 5,000 iterations showed that power was 79.1%, taking 14.7 minutes.</p>
</section>
<section id="sem-multigroup" class="level3" data-number="4.0.2">
<h3 data-number="4.0.2" class="anchored" data-anchor-id="sem-multigroup"><span class="header-section-number">4.0.2</span> ‚ÄúSEM Multigroup‚Äù</h3>
<p>Plausible effect size is set as <span class="math inline">\(B\)</span> = 0.25 (<span class="math inline">\(Y ~ X\)</span> regression coefficient between the latent variables differs by about <span class="math inline">\(\Delta\)</span> = 0.25). For 80% power, target <span class="math inline">\(SE\)</span> = 0.0892.</p>
<p>Let‚Äôs run with a maximum of 60 iterations:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"R/simulationCode/SEMmultigroup.R"</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>B <span class="ot">=</span> <span class="fl">0.25</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>target_se <span class="ot">=</span> toffee<span class="sc">::</span><span class="fu">SE4power</span>(<span class="at">B=</span>B, <span class="at">power=</span><span class="fl">0.8</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>Start <span class="ot">=</span> <span class="fu">Sys.time</span>()</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="fu">StdErr_power</span>(<span class="at">simData=</span>simData, <span class="at">target_SE =</span> target_se,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                 <span class="at">warm_up =</span> <span class="dv">30</span>, <span class="at">max_niter =</span> <span class="dv">30</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>End <span class="ot">=</span> <span class="fu">Sys.time</span>()</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>timetaken <span class="ot">=</span> <span class="fu">difftime</span>(End,Start,<span class="at">units=</span><span class="st">"mins"</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>x<span class="sc">$</span>N</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>Estimated N = 887 (95%CI: 873, 901)</li>
<li>Time taken for reaching the estimate is 0.31 minutes.</li>
</ul>
<p><strong>Double check:</strong> full power simulation with <span class="math inline">\(N\)</span> = 887 and 5,000 iterations showed that power was 76.6%, taking 12.8 minutes.</p>
</section>
<section id="mixed-effects-logistic-regression" class="level3" data-number="4.0.3">
<h3 data-number="4.0.3" class="anchored" data-anchor-id="mixed-effects-logistic-regression"><span class="header-section-number">4.0.3</span> ‚ÄúMixed-effects Logistic Regression‚Äù</h3>
<p>Plausible effect size is set as <span class="math inline">\(B\)</span> = 0.05 (this requires a bit of long explanation in the particular research scenario, but let‚Äôs say it‚Äôs about equivalent to Cohen‚Äôs d = 0.25 after the whole procedure between the treated and the control group). For 80% power, target <span class="math inline">\(StdErr\)</span> = 0.0178.</p>
<p>Let‚Äôs run with a maximum of 60 iterations:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"R/simulationCode/MixedLogisticCrossed.R"</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>B <span class="ot">=</span> <span class="fl">0.05</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>target_se <span class="ot">=</span> toffee<span class="sc">::</span><span class="fu">SE4power</span>(<span class="at">B=</span>B, <span class="at">power=</span><span class="fl">0.8</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>Start <span class="ot">=</span> <span class="fu">Sys.time</span>()</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="fu">StdErr_power</span>(<span class="at">simData=</span>simData, <span class="at">target_SE =</span> target_se,</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>                 <span class="at">warm_up =</span> <span class="dv">30</span>, <span class="at">max_niter =</span> <span class="dv">30</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>End <span class="ot">=</span> <span class="fu">Sys.time</span>()</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>timetaken <span class="ot">=</span> <span class="fu">difftime</span>(End,Start,<span class="at">units=</span><span class="st">"mins"</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>x<span class="sc">$</span>N</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>Estimated N = 494 (95%CI: 487, 501)</li>
<li>Time taken for reaching the estimate is 60.21 minutes.</li>
</ul>
<p><strong>Double check:</strong> full power simulation with <span class="math inline">\(N\)</span> = 494 and 5,000 iterations showed that power was 81.1%, taking 7.59 hours when parallelized over 6 cores, meaning a single-core process would take about 45.54 hours.</p>
</section>
</section>
<section id="conclusions" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Conclusions</h1>
<p>In all three scenarios, <span class="math inline">\(N\)</span> for desired power was estimated in 60 to 200 iterations. Double check may imply a further full power simulation for that <span class="math inline">\(N\)</span> with 5,000 iterations. A full power simulation with a vector of at least 10 different <span class="math inline">\(N\)</span> (not knowing the <span class="math inline">\(N\)</span> in advance) would have required spending 50,000 iterations. The time saved, thus, is potentially 90% to over 99.5%. When a full power simulation takes hours or days (or more), as is often the case in real-world scenarios, the gain is substantial.</p>
</section>
<section id="future-directions" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Future directions</h1>
<p>What we still need to understand:</p>
<ul>
<li>Whether there are cases in which the <span class="math inline">\(N\)</span> is difficult to estimate because the <span class="math inline">\(N\)</span>-to-<span class="math inline">\(StdErr\)</span> log-log relationship is still linear but highly noisy, or it is not even noisy;</li>
<li>How to manage multiple-variable cases in which <span class="math inline">\(StdErr\)</span> does not depend on <span class="math inline">\(N\)</span> alone, but also on <span class="math inline">\(k\)</span> number of trials (or similar multilevel situations), <span class="math inline">\(\omega\)</span> reliability, and more; this case should be more complex but not conceptually different.</li>
<li>How to expand this to the case where inference on more than one parameter is considered at once (e.g., inference is primarily based on a omnibus test);</li>
<li>What can be done when inference is made using non-parametric statistics.</li>
</ul>
<h4 class="anchored" data-anchor-id="future-directions">
<a href="N-and-k.html" target="_blank">See some preliminary computation about the issue of adapting the algorithm to the multilevel case (with <span class="math inline">\(N\)</span> subjects and <span class="math inline">\(k\)</span> trials)</a>
</h4>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>